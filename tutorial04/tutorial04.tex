\documentclass{beamer}
\mode<presentation>
{
  \usetheme{ldv}
  \setbeamercovered{transparent}
}

% Uncomment this if you're giving a presentation in german...
\usepackage[ngerman]{babel}

% ...and rename this to "Folie"
\newcommand{\slidenomenclature}{Folie}


\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{times}
\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage{array}
\usepackage{colortbl}
\usepackage{tabularx}

% Uncomment me when you need to insert code
\usepackage{color}
\usepackage{listings}
\usepackage{minted}
\usepackage{algpseudocode}
% End Code

\usepackage{datetime}
\usepackage{tikz}

\usetikzlibrary{calc}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{decorations.pathreplacing}

% Uncomment me when you need video or sound
% \usepackage{multimedia}
% \usepackage{hyperref}
% End video

% Header
\newcommand{\zwischentitel}{Woche 4}
\newcommand{\leitthema}{Tobias Eppacher}
\newcommand{\presdatum}{\formatdate{19}{5}{2025}}
% End Header

% Titlepage
\title{Grundlagen: Algorithmen und Datenstrukturen}
\author{Tobias Eppacher}
\date{\presdatum}
\institute{School of Computation, Information and Technology}
\subtitle{Woche 4}
% End Titlepage


% Slides
\begin{document}

% 1. Slide: Titlepage
\begin{frame}
	\titlepage{}
\end{frame}

% 2. Slide: TOC
\begin{frame}
	\frametitle{Table of contents}
	\tableofcontents[subsectionstyle=hide]
\end{frame}

% Further Slides
\section{Aufgaben}

\subsection{Sortierverfahren}
\begin{frame}
	\frametitle{Aufgabe 4.1 - Sortierverfahren}
	Zahlenfolge: $[523, 126, 67, 1, 500, 34, 21, 229, 9, 123, 13]$

	\smallskip

	\textbf{(a) Mergesort:} \\
	Ein Zwischenschritt je Aufteilen und Verschmelzen (hier ca. 8 Schritte). \\
	Teilen ungerader Länge $\rightarrow$ Linke Seite eins mehr.

	\smallskip

	\textbf{(b) Quicksort:} \\
	Wie in der Vorlesung $\rightarrow$ letztes Element $=$ Pivot. \\
	Machen Sie kenntlich welches Pivot in jedem Schritt verwendet wird und geben
	Sie das Array nach jedem Umsortieren an.
	Sortierschritte auf zwei nicht überlagernden Abschnitten der Zahlenfolge
	können im selben Schritt dargestellt werden. \\
	Bei Teilsequenzen der Länge 2 kann direkt ohne Rekursion getauscht werden.

	\smallskip

	\textbf{(c)} Welches Sortierverfahren ist im Worst- bzw. Averagecase schneller?
\end{frame}

\begin{frame}[t]
	\frametitle{Aufgabe 4.1 - Sortierverfahren (a)}
	\begin{tikzpicture}
		\foreach [count=\i from 0] \n in {523,126,67,1,500,34,21,229,9,123,13} {
				\node [draw, minimum size=0.7cm, font=\scriptsize] at (\i,0) {\n};
			}
	\end{tikzpicture}
\end{frame}

\begin{frame}[t]
	\frametitle{Aufgabe 4.1 - Sortierverfahren (b)}
	\begin{tikzpicture}
		\foreach [count=\i from 0] \n in {523,126,67,1,500,34,21,229,9,123,13} {
				\node [draw, minimum size=0.7cm, font=\scriptsize] at (\i,0) {\n};
			}
	\end{tikzpicture}
\end{frame}

\begin{frame}[t]
	\frametitle{Aufgabe 4.1 - Sortierverfahren (c)}
	Welches Sortierverfahren ist im Worst- bzw. Averagecase schneller?
\end{frame}

\subsection{Bankkonto Tutorial}
\begin{frame}
	\frametitle{Aufgabe 4.2 - Bankkonto Tutorial}
	\begin{columns}
		\begin{column}{0.3\textwidth}

			\begin{tikzpicture}
				% Paths, nodes and wires:
				\node[shape=ellipse, draw, line width=1pt, inner sep=0, minimum width=2.715cm, minimum height=4.215cm] at (6, 4.75){};
				\node[shape=circle, draw, line width=1pt, inner sep=0, minimum width=0.465cm](Ellipse1) at (5.875, 6.125){} node[anchor=center] at (Ellipse1.center){$\sigma_a$};
				\node[shape=circle, draw, line width=1pt, inner sep=0, minimum width=0.465cm](Ellipse2) at (5.302, 4.948){} node[anchor=center] at (Ellipse2.center){$\sigma_b$};
				\node[shape=circle, draw, line width=1pt, inner sep=0, minimum width=0.465cm](Ellipse3) at (6.698, 4.198){} node[anchor=center] at (Ellipse3.center){$\sigma_c$};
				\node[shape=circle, draw, line width=1pt, inner sep=0, minimum width=0.465cm](Ellipse4) at (5.698, 3.302){} node[anchor=center] at (Ellipse4.center){$\sigma_d$};
				\node[shape=rectangle, inner sep=0, minimum width=0.965cm, minimum height=0.465cm](Rect1) at (6, 7.25){} node[anchor=center] at (Rect1.center){$S$};
			\end{tikzpicture}
		\end{column}
		\begin{column}{0.7\textwidth}
			Menge von Operationen: $S$

			\medskip

			(Obere Schranke für) Laufzeit von Operation $\sigma \in S$: $T(\sigma)$

			\medskip

			(Obere Schranke für) Laufzeit einer Folge von $m$ Operationen:
			$T(\sigma_1, \sigma_2, \dots, \sigma_m) := \sum_{i=1}^{m} T(\sigma_i)$

			\bigskip

			\textbf{Ziel der Amortisierten Analyse} \\
			\smallskip
			Möglichst genaue obere Schranke für $T(\sigma_1, \sigma_2, \dots, \sigma_m)$ finden
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[t]
	\frametitle{Aufgabe 4.2 - Bankkonto Tutorial}

	\textbf{Bankkonto Methode}

	\bigskip

	\textbf{Idee:} Verteile Laufzeit von langsamen auf schnellere Operationen

	\medskip

	$\Rightarrow$ Bessere Abschätzung der Laufzeit
\end{frame}

\begin{frame}[t]
	\frametitle{Aufgabe 4.2 - Bankkonto Tutorial}

	\textbf{Bankkonto Methode}

	\bigskip

	\textbf{Idee:} Verteile Laufzeit von langsamen auf schnellere Operationen

	\medskip

	$\Rightarrow$ Bessere Abschätzung der Laufzeit

	\bigskip

	\begin{tikzpicture}[scale=0.7, transform shape]
		% Paths, nodes and wires:
		\node[shape=rectangle, draw=red, line width=1pt, inner sep=0, minimum width=1cm, minimum height=3cm]
		(Rect1) at (0, 4){} node[anchor=center] at (Rect1.center){$\sigma_{n+1}$};
		\node[shape=rectangle, draw, line width=1pt, inner sep=0, minimum width=1cm, minimum height=1cm]
		(Rect2) at (0, 2){} node[anchor=center] at (Rect2.center){$\sigma_n$};
		\node[shape=rectangle, draw, line width=1pt, inner sep=0, minimum width=1cm, minimum height=1cm]
		(Rect3) at (0, 1){} node[anchor=center] at (Rect3.center){$\dots$};
		\node[shape=rectangle, draw, line width=1pt, inner sep=0, minimum width=1cm, minimum height=1cm]
		(Rect4) at (0, 0){} node[anchor=center] at (Rect4.center){$\sigma_1$};

		\node[shape=rectangle, draw, line width=1pt, inner sep=0, minimum width=1cm, minimum height=1cm]
		(Rect5) at (4, 0){} node[anchor=center] at (Rect5.center){$\sigma_1$};
		\node[shape=rectangle, draw=red, line width=1pt, inner sep=0, minimum width=1cm, minimum height=1cm]
		(Rect6) at (4, 1){} node[anchor=center] at (Rect6.center){$1$};
		\node[shape=rectangle, draw, line width=1pt, inner sep=0, minimum width=1cm, minimum height=1cm]
		(Rect7) at (6, 0){} node[anchor=center] at (Rect7.center){$\sigma_2$};
		\node[shape=rectangle, draw=red, line width=1pt, inner sep=0, minimum width=1cm, minimum height=1cm]
		(Rect8) at (6, 1){} node[anchor=center] at (Rect8.center){$1$};
		\node[shape=rectangle, draw, line width=1pt, inner sep=0, minimum width=1cm, minimum height=1cm]
		(Rect9) at (8, 0){} node[anchor=center] at (Rect9.center){$\dots$};
		\node[shape=rectangle, draw=red, line width=1pt, inner sep=0, minimum width=1cm, minimum height=1cm]
		(Rect10) at (8, 1){} node[anchor=center] at (Rect10.center){$\dots$};
		\node[shape=rectangle, draw, line width=1pt, inner sep=0, minimum width=1cm, minimum height=1cm]
		(Rect11) at (10, 0){} node[anchor=center] at (Rect11.center){$\sigma_n$};
		\node[shape=rectangle, draw=red, line width=1pt, inner sep=0, minimum width=1cm, minimum height=1cm]
		(Rect12) at (10, 1){} node[anchor=center] at (Rect12.center){$1$};

		\draw[decorate, decoration={brace, mirror, amplitude=5pt}, thick]
		(-0.7,5.5) -- (-0.7,2.5) node[midway, xshift=-1.5cm] {\footnotesize\shortstack{1 Operation \\ Laufzeit $n$}};
		\draw[decorate, decoration={brace, mirror, amplitude=5pt}, thick]
		(-0.7,2.5) -- (-0.7,-0.5) node[midway, xshift=-1.5cm] {\footnotesize\shortstack{$n$ Operationen \\ mit Laufzeit $1$}};

		\draw[->, thick, red] (0.6,4) -- (3.9, 1.6);
		\draw[->, thick, red] (0.6,4) -- (5.9, 1.6);
		\draw[->, thick, red] (0.6,4) -- (7.9, 1.6);
		\draw[->, thick, red] (0.6,4) -- (9.9, 1.6);
	\end{tikzpicture}
\end{frame}

\begin{frame}[t]
	\frametitle{Aufgabe 4.2 - Bankkonto Tutorial}

	\begin{itemize}
		\item Schnelle Operationen können Laufzeit übernehmen \\
		      $\Rightarrow$ Zahlen Tokens auf Konto ein ("nicht verwendete Zeit")
		\item Mehrere schnelle Operationen sparen Tokens an
		\item Folgende langsame Operation kann Tokens abheben \\
		      $\Rightarrow$ Gesparte Zeit wird aufgebraucht
	\end{itemize}

	\bigskip

	Wir definieren die Funktion $\Delta: S \to \mathbb{R}$ die bestimmt, wieviele Tokens eine Operation einzahlt oder abhebt. \\
	Diese muss zwei Eigenschaften erfüllen:

	\medskip

	\begin{enumerate}
		\item Für legale Operationsfolgen: $\sum_{i=1}^{m} \Delta(\sigma_i) \geq 0$ \\
		      (Konto darf nie negativ werden)
		\item $\Delta$ ist möglichst gut gewählt. \textit{(Dazu gleich mehr)}
	\end{enumerate}
\end{frame}

\begin{frame}
	\frametitle{Aufgabe 4.2 - Bankkonto Tutorial}

	\textbf{Amortisierte Laufzeit}

	\medskip

	Für eine Operation: \\
	$$A(\sigma) := T(\sigma) + \Delta(\sigma)$$

	Für eine Folge von Operationen: \\
	$$A(\sigma_1,\dots\sigma_m) = \sum_{i=1}^{m} A(\sigma_i) = \sum_{i=1}^{m} T(\sigma) + \Delta(\sigma)$$
	$$= T(\sigma_1,\dots\sigma_m) + \underbrace{\sum_{i=1}^{m} \Delta{(\sigma_i)}}_{\geq 0} \geq T(\sigma_1,\dots\sigma_m)$$

	$\Rightarrow$ Amortisierte Laufzeit ist eine \textit{obere Schranke} für die tatsächliche Laufzeit
\end{frame}

\begin{frame}[t]
	\frametitle{Aufgabe 4.2 - Bankkonto Tutorial}

	\textbf{Wie wählt man $\Delta$?}

	\medskip

	Häufig sinnvoll: \\
	Amortisierte Laufzeit der schlechtesten Operation möglichst niedrig halten
	(i.e. minimiere $\max_{\sigma \in S}(A(\sigma))$)

	\bigskip

	\textbf{Beispiel:}

	\begin{itemize}
		\item Operationsfolge: $S = \{ \sigma_1, \sigma_2, \dots, \sigma_m \}$
		\item Schema mit $\max_{\sigma \in S}(A(\sigma))$ möglichst klein, gefunden
	\end{itemize}

	\medskip

	$\Rightarrow$ Asymptotische Worst-Case Laufzeit ist in
	$$\mathcal{O}(m \cdot \max_{\sigma \in S}(A(\sigma)))$$

\end{frame}

\begin{frame}
	\frametitle{Aufgabe 4.3 - Amortisation}

	\textbf{Der Zähler}

	\medskip

	Wir starten einen Zähler mit $0$ und haben eine Folge von $m$ Inkrement-Operationen.
	(D.h. Operation $\sigma_k$: Zähler $k-1 \rightarrow k$)

	\medskip

	Zähler arbeitet in Dezimalschreibweise (Ziffern $0-9$ pro Stelle)

	\medskip

	Änderung einer Stelle hat Laufzeit 1

	\bigskip

	\textbf{Beispiele:}

	\medskip

	$\sigma_{134}: \text{Zähler } 13\mathcolor{blue}{3} \rightarrow 13\mathcolor{blue}{4} \implies$ Laufzeit 1 \\
	$\sigma_{240}: \text{Zähler } 2\mathcolor{blue}{3}\mathcolor{red}{9} \rightarrow 2\mathcolor{blue}{4}\mathcolor{red}{0} \implies$ Laufzeit 2 \\
	$\sigma_{9999}: \text{Zähler } \mathcolor{blue}{0}\mathcolor{red}{9999} \rightarrow \mathcolor{blue}{1}\mathcolor{red}{0000} \implies$ Laufzeit 5
\end{frame}

\begin{frame}
	\frametitle{Aufgabe 4.3 - Amortisation}

	\hangindent=1.5em\hangafter=1
	\textbf{(a)} Definieren Sie ein zulässiges Amortisationsschema $\Delta: {\sigma_1, \sigma_2, \dots} \to \mathbb{R}$ der Bankkonto-Methode, sodass für jede Inkrementoperation $\sigma_k$ gilt:
	$$A(\sigma_k) = T(\sigma_k) + \Delta(\sigma_k) = \frac{10}{9}$$

	\smallskip

	\hangindent=1.5em\hangafter=1
	\textbf{(b)} Zeigen Sie, dass Ihr Amortisationsschema zulässig ist, indem Sie nachweisen, dass das
	Tokenkonto stets nichtnegativ ist.

	\bigskip

	Verwenden Sie folgende Definitionen:
	\begin{align*}
		S_{x \rightarrow x+1}(\sigma_k) \quad & \text{\#Stellen die } \sigma_k \text{ von } x \text{ zu } x+1 \text{ setzt} \\
		S_{9 \rightarrow 0}(\sigma_k) \quad   & \text{\#Stellen die } \sigma_k \text{ von } 9 \text{ zu } 0 \text{ setzt}
	\end{align*}
\end{frame}

\begin{frame}
	\frametitle{Aufgabe 4.3 - Amortisation (a)}
\end{frame}

\begin{frame}
	\frametitle{Aufgabe 4.3 - Amortisation (b)}
\end{frame}

\begin{frame}
	\frametitle{Aufgabe 4.4 - Dynamisches Array}

	\begin{tabular}{>{$}l<{$} @{${}\quad\;$} p{\textwidth}}
		\alpha > \beta > 0 & \text{Wachstums-/Verkleinerungs-Faktoren } ($\alpha, \beta \in \mathbb{N}$) \\
		n                  & \text{Aktuelle Anzahl der Elemente im Array}                                \\
		w                  & \text{Größe des Arrays}
	\end{tabular}

	\medskip

	\textbf{Operationen:}
	\begin{itemize}
		\item \mintinline{java}{pushBack}: Einfügen am Ende des Arrays
		\item \mintinline{java}{popBack}: Löschen des letzten Elements
		\item \mintinline{java}{reallocate}: Vergrößern/Verkleinern des Arrays
	\end{itemize}

	\medskip

	\textbf{Wann wird} \mintinline{java}{reallocate} \textbf{aufgerufen?}
	\begin{itemize}
		\item Array voll ($n = w$) und \mintinline{java}{pushBack} wird aufgerufen\\
		      $\Rightarrow$ neues Array mit Größe $\beta n$ + Kopieren und Einfügen
		\item Nach \mintinline{java}{popBack} zu leer (d.h. $\alpha \cdot n \leq w$) \\
		      $\Rightarrow$ neues Array mit Größe $\beta n$ + Kopieren
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Aufgabe 4.4 - Dynamisches Array}

	\begin{small}

		\hangindent=1.5em\hangafter=1
		\textbf{(a)} Zeigen Sie, dass dieses Amortisationsschema zulässig ist, indem Sie zeigen, dass das
		Tokenkonto zu jedem Zeitpunkt nichtnegativ ist.

		\hangindent=3.25em
		\begin{scriptsize}
			Hinweis: Bezeichne $n_1$ die Zahl der Elemente unmittelbar nach einem \mintinline{java}{reallocate} (bei \mintinline{java}{pushBack} also vor dem Einfügen des neuen Elements).
			Die Arraygröße zu diesem Zeitpunkt ist $w_1 := \beta \cdot n_1$ und es sind $w_1 - n_1$ Positionen frei.
			Das nächste \mintinline{java}{reallocate} wird erst dann aufgerufen, wenn für die Zahl $n$ der Elemente entweder $n = w_1$ oder $\alpha n \leq w_1$ gilt.
		\end{scriptsize}

		\bigskip

		\hangindent=1.5em\hangafter=1
		\textbf{(b)} Zeigen Sie, dass unter diesem Amortisationsschema die amortisierte Laufzeit jeder Operation in $\mathcal{O}(1)$ liegt, und folgern Sie, dass die Worst-Case-Laufzeit für Operationsfolgen der Länge $m$ in $\mathcal{O}(m)$ liegt.

	\end{small}
\end{frame}

\begin{frame}
	\frametitle{Aufgabe 4.4 - Dynamisches Array (a)}
\end{frame}

\begin{frame}
	\frametitle{Aufgabe 4.4 - Dynamisches Array (a)}
\end{frame}

\begin{frame}
	\frametitle{Aufgabe 4.4 - Dynamisches Array (a)}
\end{frame}

\begin{frame}
	\frametitle{Aufgabe 4.4 - Dynamisches Array (b)}
\end{frame}

\section{E-Aufgaben}
\begin{frame}
	\frametitle{E-Aufgaben}
	\begin{itemize}
		\item Aufgabe 4.5 - Quicksort Worstcase \\
		      \begin{itemize}
			      \item Worstcase Suche für verschiedene Pivot-Wahlen
		      \end{itemize}
		\item Aufgabe 4.6 - Noch mehr Spaß mit $\Delta\text{mortisation}$
		      \begin{itemize}
			      \item Weitere Übung zum Finden von Amortisationschema
		      \end{itemize}
	\end{itemize}
\end{frame}

\section{Hausaufgaben}
\begin{frame}
	\frametitle{Hausaufgaben}
	\begin{itemize}
		\item Hausaufgabe 3 - Dynamisches Array \\
		      (Deadline: 28.05.2025)
		\item Hausaufgabe 4 - Verbessertes Sortieren \\
		      (Deadline: 28.05.2025)
	\end{itemize}
\end{frame}

\begin{frame}
	\textbf{Fragen?}
	\begin{itemize}
		\item Nach Übung gerne bei mir melden
		\item Tutoriumschannel oder DM an mich auf Zulip
		\item Vorlesungschannels von GAD auf Zulip (insbesondere bei Hausaufgaben)
	\end{itemize}

	\medskip
	\textbf{Feedback oder Verbesserungsvorschläge?} \\
	Gerne nach dem Tutorium mit mir quatschen oder DM auf Zulip

	\medskip
	\textbf{Bis nächste Woche!}
\end{frame}

% End Slides

\end{document}
